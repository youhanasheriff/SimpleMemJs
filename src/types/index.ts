/**
 * SimpleMem Core Type Definitions
 *
 * TypeScript port of Python models/memory_entry.py
 * Based on the SimpleMem paper: Semantic Lossless Compression for LLM agents
 */

import { z } from "zod";

// =============================================================================
// Dialogue Types
// =============================================================================

/**
 * Raw dialogue entry from user input
 */
export const DialogueSchema = z.object({
  id: z.number(),
  speaker: z.string(),
  content: z.string(),
  timestamp: z.string().optional(), // ISO-8601
});

export type Dialogue = z.infer<typeof DialogueSchema>;

// =============================================================================
// Memory Unit Types (Atomic Entries)
// =============================================================================

/**
 * Salience level for memory entries
 */
export const SalienceSchema = z.enum(["high", "medium", "low"]);
export type Salience = z.infer<typeof SalienceSchema>;

/**
 * Atomic Memory Unit - Self-contained, disambiguated fact
 *
 * Paper Reference: Section 3.1 - Eq. (3), (4)
 * Generated by De-linearization: m_k = F_θ(W_t) = Φ_time ∘ Φ_coref ∘ Φ_extract(W_t)
 * Indexed via: M(m_k) = {v_k (semantic), h_k (lexical), R_k (symbolic)}
 */
export const MemoryUnitSchema = z.object({
  // Unique identifier
  id: z.string().uuid(),

  // [Semantic Layer] - Dense embedding base (v_k = E_dense(S_k))
  content: z
    .string()
    .describe(
      "Self-contained fact with resolved coreferences (no pronouns) and absolute timestamps",
    ),

  // [Lexical Layer] - Sparse keyword vectors (h_k = Sparse(S_k))
  keywords: z
    .array(z.string())
    .default([])
    .describe("Core keywords for BM25-style exact matching"),

  // [Symbolic Layer] - Metadata constraints (R_k = {(key, val)})
  timestamp: z.string().optional().describe("ISO-8601 timestamp"),
  location: z.string().optional().describe("Natural language location"),
  persons: z.array(z.string()).default([]).describe("Extracted person names"),
  entities: z
    .array(z.string())
    .default([])
    .describe("Extracted entities (products, companies, etc.)"),
  topic: z.string().optional().describe("Topic phrase"),
  salience: SalienceSchema.default("medium"),

  // Vector embedding (added during indexing)
  embedding: z.array(z.number()).optional(),

  // Metadata
  sourceDialogueIds: z.array(z.number()).default([]),
  createdAt: z.string().optional(),
});

export type MemoryUnit = z.infer<typeof MemoryUnitSchema>;

// =============================================================================
// Abstract Memory Types (Consolidated Patterns)
// =============================================================================

/**
 * Abstract Memory - Consolidated pattern from multiple memory units
 *
 * Paper Reference: Section 3.2 - Recursive Consolidation
 * Created when cluster affinity exceeds τ_cluster threshold
 */
export const AbstractMemorySchema = z.object({
  id: z.string().uuid(),
  pattern: z.string().describe("Abstract pattern description"),
  sourceUnitIds: z
    .array(z.string())
    .describe("IDs of consolidated memory units"),
  frequency: z.number().describe("Occurrence count"),
  firstOccurrence: z.string().describe("Earliest timestamp"),
  lastOccurrence: z.string().describe("Most recent timestamp"),
  entities: z
    .array(z.string())
    .default([])
    .describe("Union of entities from sources"),
  embedding: z.array(z.number()).optional(),
  isArchived: z.boolean().default(false),
});

export type AbstractMemory = z.infer<typeof AbstractMemorySchema>;

// =============================================================================
// Query Analysis Types
// =============================================================================

/**
 * Query complexity level
 */
export const QueryComplexitySchema = z.enum(["LOW", "HIGH"]);
export type QueryComplexity = z.infer<typeof QueryComplexitySchema>;

/**
 * Query analysis result from LLM
 */
export const QueryAnalysisSchema = z.object({
  complexity: QueryComplexitySchema,
  rationale: z.string(),
  lexicalKeywords: z.array(z.string()),
  temporalConstraints: z
    .object({
      start: z.string().optional(),
      end: z.string().optional(),
    })
    .optional(),
  semanticQuery: z.string(),
});

export type QueryAnalysis = z.infer<typeof QueryAnalysisSchema>;

// =============================================================================
// Retrieval Types
// =============================================================================

/**
 * Retrieved context for answering queries
 */
export const RetrievalContextSchema = z.object({
  abstracts: z.array(AbstractMemorySchema),
  units: z.array(MemoryUnitSchema),
  totalTokens: z.number(),
  retrievalRationale: z.string().optional(),
});

export type RetrievalContext = z.infer<typeof RetrievalContextSchema>;

// =============================================================================
// Configuration Types
// =============================================================================

/**
 * SimpleMem configuration options
 */
export interface SimpleMemConfig {
  // LLM Provider
  llm: LLMProvider;

  // Embedding Provider
  embeddings: EmbeddingProvider;

  // Storage Adapter (optional, defaults to in-memory)
  storage?: StorageAdapter;

  // Stage 1: Compression parameters
  windowSize?: number; // Default: 40
  overlapSize?: number; // Default: 2
  redundancyThreshold?: number; // τ_redundant, default: 0.3

  // Stage 2: Indexing parameters
  clusterThreshold?: number; // τ_cluster, default: 0.75
  temporalDecay?: number; // γ, default: 0.1

  // Stage 3: Retrieval parameters
  semanticTopK?: number; // Default: 25
  keywordTopK?: number; // Default: 5
  structuredTopK?: number; // Default: 5
  semanticWeight?: number; // α, default: 0.6
  lexicalWeight?: number; // β, default: 0.3
  baseRetrievalK?: number; // k_base, default: 3
  complexityDelta?: number; // δ, default: 2.0

  // Advanced options
  enablePlanning?: boolean; // Default: true
  enableReflection?: boolean; // Default: true
  maxReflectionRounds?: number; // Default: 2
}

// =============================================================================
// Provider Interfaces
// =============================================================================

/**
 * LLM Provider interface
 */
export interface LLMProvider {
  /**
   * Generate a completion for the given prompt
   */
  complete(prompt: string, options?: LLMCompletionOptions): Promise<string>;

  /**
   * Generate a structured JSON response
   */
  completeJSON<T>(prompt: string, schema: z.ZodType<T>): Promise<T>;
}

export interface LLMCompletionOptions {
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

/**
 * Embedding Provider interface
 */
export interface EmbeddingProvider {
  /**
   * Generate embeddings for multiple texts
   */
  embed(texts: string[]): Promise<number[][]>;

  /**
   * Embedding dimension
   */
  readonly dimensions: number;
}

// =============================================================================
// Storage Adapter Interface
// =============================================================================

/**
 * Query filter for storage operations
 */
export interface QueryFilter {
  persons?: string[];
  entities?: string[];
  timestampRange?: { start?: string; end?: string };
  location?: string;
  topic?: string;
}

/**
 * Storage Adapter interface
 */
export interface StorageAdapter {
  /**
   * Save a memory unit
   */
  saveUnit(unit: MemoryUnit): Promise<void>;

  /**
   * Save multiple memory units
   */
  saveUnits(units: MemoryUnit[]): Promise<void>;

  /**
   * Get a memory unit by ID
   */
  getUnit(id: string): Promise<MemoryUnit | null>;

  /**
   * Get all memory units
   */
  getAllUnits(): Promise<MemoryUnit[]>;

  /**
   * Query memory units with filters
   */
  queryUnits(filter: QueryFilter): Promise<MemoryUnit[]>;

  /**
   * Delete a memory unit
   */
  deleteUnit(id: string): Promise<void>;

  /**
   * Save an abstract memory
   */
  saveAbstract(abstract: AbstractMemory): Promise<void>;

  /**
   * Get all abstract memories
   */
  getAllAbstracts(): Promise<AbstractMemory[]>;

  /**
   * Clear all data
   */
  clear(): Promise<void>;

  /**
   * Export all data
   */
  export(): Promise<ExportData>;

  /**
   * Import data
   */
  import(data: ExportData): Promise<void>;
}

/**
 * Export data format
 */
export interface ExportData {
  units: MemoryUnit[];
  abstracts: AbstractMemory[];
  version: string;
  exportedAt: string;
}

// =============================================================================
// Search Result Types
// =============================================================================

export interface SearchResult {
  unit: MemoryUnit;
  score: number;
  matchType: "semantic" | "lexical" | "symbolic" | "hybrid";
}

export interface SearchOptions {
  limit?: number;
  filter?: QueryFilter;
  includeEmbeddings?: boolean;
}
